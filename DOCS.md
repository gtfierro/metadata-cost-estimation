*these docs were generated by o3-mini on 2025-06-03 and double-checked/edited by @gtfierro*

---

## Table of Contents

- [Overview](#overview)
- [Input Format](#input-format)
  - [JSON Rules File Structure](#json-rules-file-structure)
  - [Rule Example](#rule-example)
- [Transformation Process](#transformation-process)
  - [General Flow](#general-flow)
- [Working Example](#working-example)
- [Execution Instructions](#execution-instructions)
- [Additional Notes](#additional-notes)

---

## Overview

The transformation process is designed to convert rule definitions provided in a JSON file into corresponding SHACL shapes (and optionally SPARQL queries) using the RDFLib library. Rules are defined in a high-level, declarative JSON syntax that specifies target classes, applicability conditions, and property definitions. The resulting output is a set of RDF triples representing SHACL node shapes that can be used for data validation or as part of an inferred rules system.

---

## Input Format

### JSON Rules File Structure

The input file is a JSON document where each top-level key corresponds to a rule name. The value associated with each rule is an object that contains various properties and sub-definitions that describe the rule. These properties typically include:

- **name**: A human-readable name for the rule.
- **aftype**: A type descriptor (e.g., "analysis").
- **aftimerule**: A rule type for timing (e.g., "Periodic").
- **frequency**: An optional frequency value (in seconds).
- **applicability**: A list of strings indicating the building elements (or classes) to which the rule applies.
- **definitions**: A JSON object that contains the mapping of sub-definitions. Each definition can be:
  - A string (interpreted as a class name that maps directly to a BRICK class).
  - A dictionary representing more complex constructions, including:
    - **choice**: A list of alternative possibilities.
    - **union**: A union of shape requirements.
    - Nested property structures to represent relationships such as hasPoint, hasPart, etc.
- **output**: (Optional) A rule output expressed in natural language-like statement (e.g., conditional output, for example "IF ... THEN ...").

### Rule Example

Below is an example rule in JSON format:

```json
{
  "SimultaneousHeatingAndCooling": {
    "name": "Simultaneous Heating and Cooling",
    "aftype": "analysis",
    "aftimerule": "Periodic",
    "frequency": 900,
    "applicability": ["AHU", "RTU", "RVAV"],
    "definitions": {
      "Chilled_Water_Valve_Command": {
        "choice": [
          {"hasPoint": "Chilled_Water_Valve_Command"},
          {"hasPart": {"Chilled_Water_Valve": {"hasPoint": "Valve_Command"}}}
        ]
      },
      "Hot_Water_Valve_Command": {
        "choice": [
          {"hasPoint": "Hot_Water_Valve_Command"},
          {"hasPart": {"Hot_Water_Valve": {"hasPoint": "Valve_Command"}}}
        ]
      }
    },
    "output": "IF Chilled_Water_Valve_Command AND Hot_Water_Valve_Command THEN True ELSE False"
  }
}
```

- The **SimultaneousHeatingAndCooling** rule applies to devices such as AHU, RTU, and RVAV.
- Under **definitions**, two keys specify different parts of the rule:
  - **Chilled_Water_Valve_Command** is defined with a **choice** between:
    - A direct property ("hasPoint") carrying the value.
    - A nested structure where the property ("hasPart") leads to another class that itself has a property.
  - **Hot_Water_Valve_Command** follows a similar pattern.

## Transformation Process

The transformation process reads the JSON rules and produces a SHACL graph by converting each rule definition into RDF triples. These RDF triples define node shapes that specify constraints on data properties. The transformation involves the following main steps:

1. **Parsing the Input**:
   The JSON document is loaded, and the transformation iterates over each rule.

2. **Generating SHACL Shapes for Each Rule**:
   For each rule, a main node shape is created in the target namespace. Each shape is a `sh:NodeShape`, `owl:Class` and `InferredRuleShape`. We use the latter type to annotate the generated shapes and differentiate them from any dependent (internal) shapes.

3. **Setting Target Classes**:
   The `applicability` property of each rule is used to add `sh:targetClass` statements, indicating which building elements (BRICK classes) the rule targets.

4. **Processing Rule Definitions**:
   Each sub-definition under the `definitions` property is processed recursively:
   - Simple string definitions are converted directly into property shapes using the default `hasPoint` property.
   - Complex definitions containing keys such as **choice** or **union** trigger dedicated functions to create either `sh:or` or `sh:and` constraints:
     - **choice** is handled by the `choice_to_shape` function.
     - **union** is handled by the `union_to_shape` function.
   - Definitions that are dictionaries with property keys are processed by the `prop_to_shape` function which may call helper functions to deal with nested relationships and generate appropriate property paths.

5. **Property Path Resolution**:
   When a nested structure represents a series of relationships (for example, a chain of properties such as `hasPart` then `hasPoint`), the `edge_list_to_property_path` function is used. This function translates a list of property edges into an RDF representation using SHACL property path constructs (e.g., `sh:zeroOrOnePath`, `sh:oneOrMorePath`).

6. **Consolidation of SHACL Graph**:
   After processing individual rules, the resulting shapes (each as an RDFLib `Graph`) are merged into a single SHACL graph. Additionally, ontology metadata and any specified imports are added.

## Working Example

Given the sample JSON rule (see the **Rule Example** section), the transformation process produces a SHACL graph resembling the following (in Turtle syntax):

```turtle
:Chilled_Water_Valve a sh:NodeShape ;
    sh:class brick:Chilled_Water_Valve ;
    sh:property [
        sh:path brick:hasPoint ;
        sh:qualifiedValueShape [ sh:class brick:Valve_Command ] ;
        sh:qualifiedMinCount 1 ;
    ] .

:Hot_Water_Valve a sh:NodeShape ;
    sh:class brick:Hot_Water_Valve ;
    sh:property [
        sh:path brick:hasPoint ;
        sh:qualifiedValueShape [ sh:class brick:Valve_Command ] ;
        sh:qualifiedMinCount 1 ;
    ] .

:SimultaneousHeatingAndCooling a sh:NodeShape ;
    sh:targetClass brick:AHU, brick:RTU, brick:RVAV ;
    sh:or (
        [ sh:name "Chilled_Water_Valve_Command" ;
          sh:path brick:hasPoint ;
          sh:qualifiedValueShape [ sh:class brick:Chilled_Water_Valve_Command ] ;
          sh:qualifiedMinCount 1 ],
        [ sh:name "Chilled_Water_Valve_Command" ;
          sh:path brick:hasPart ;
          sh:qualifiedValueShape [ sh:node :Chilled_Water_Valve ] ;
          sh:qualifiedMinCount 1 ]
    ) ;
    sh:or (
        [ sh:name "Hot_Water_Valve_Command" ;
          sh:path brick:hasPoint ;
          sh:qualifiedValueShape [ sh:class brick:Hot_Water_Valve_Command ] ;
          sh:qualifiedMinCount 1 ],
        [ sh:name "Hot_Water_Valve_Command" ;
          sh:path brick:hasPart ;
          sh:qualifiedValueShape [ sh:node :Hot_Water_Valve ] ;
          sh:qualifiedMinCount 1 ]
    ) .
```

*Notes on the Example:*
- Each component (e.g., `Chilled_Water_Valve`, `Hot_Water_Valve`) gets its own shape.
- The `SimultaneousHeatingAndCooling` shape uses `sh:or` constraints to combine multiple alternative conditions.
- The property shapes ensure that at least one qualifying property is present (with `sh:qualifiedMinCount 1`).

## Execution Instructions

1. **Prepare the JSON Rules File**:
   Create a JSON file (e.g., `rules.json`) that contains your rule definitions using the structure described above.

2. **Run the Script**:
   Execute the transformation script from the command line:
   ```
   uv run python transform.py rules.json output.ttl
   ```
   - Here, `rules.json` is your input file.
   - `output.ttl` is the file where the SHACL graph will be serialized in Turtle format.

3. **Review the Output**:
   The output file (`output.ttl`) will contain the RDF triples that represent the SHACL shapes, which can then be used for further validation or integration with other systems.
